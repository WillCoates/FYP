package business

import (
	"context"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"time"

	"github.com/WillCoates/FYP/auth/model"
	"github.com/WillCoates/FYP/common/auth"
	"go.mongodb.org/mongo-driver/bson"
)

// ErrCodeExpired is returned by RetrieveAuthCode when it is called with an
// auth code generated by CreateAuthCode more than 2 minutes ago
var ErrCodeExpired = errors.New("Authentication code expired")

// ErrWrongRedirect is returned by RetrieveAuthCode when it is called with a
// different redirect to what the CreateAuthCode was provided
var ErrWrongRedirect = errors.New("Wrong redirect provided")

// ErrAuthCodeAlready claimed is returned by RetrieveAuthCode when the same
// auth code has been passed twice
var ErrAuthCodeAlreadyClaimed = errors.New("Auth code already claimed")

// CreateAuthCode generates an OAuth2 authentication code from a token
func (logic *Logic) CreateAuthCode(ctx context.Context, token *auth.Token, redirect string, challenge *model.Challenge) (string, error) {
	codes := logic.db.Collection("auth_codes")

	encoded, err := logic.EncodeToken(token)

	if err != nil {
		return "", err
	}

	hash := sha256.Sum256(encoded)
	code := base64.RawURLEncoding.EncodeToString(hash[:])
	expires := time.Now().Add(2 * time.Minute).Unix()

	document := bson.M{"code": code, "token": string(encoded), "expires": expires, "redirect": redirect, "claimed": false}
	if challenge != nil {
		document["challenge"] = challenge
	}

	_, err = codes.InsertOne(ctx, document)

	if err != nil {
		return "", err
	}

	return code, nil
}

// RetrieveAuthCode retrieves a token from an OAuth2 authentication code
func (logic *Logic) RetrieveAuthCode(ctx context.Context, code, redirect, challengeSolution string) (string, error) {
	codes := logic.db.Collection("auth_codes")
	var document model.AuthCode

	err := codes.FindOneAndUpdate(ctx, bson.M{"code": code}, bson.M{"$set": bson.M{"claimed": true}}).Decode(&document)

	if err != nil {
		return "", err
	}

	parsedToken, err := logic.DecodeTokenStr(document.Token)

	if err != nil {
		return "", err
	}

	if document.Claimed {
		// Invalidate token as it's potentially compromised
		logic.InvalidateToken(context.Background(), parsedToken)
		return "", ErrAuthCodeAlreadyClaimed
	}

	if document.Expires <= time.Now().Unix() {
		return "", ErrCodeExpired
	}

	if document.Redirect != redirect {
		return "", ErrWrongRedirect
	}

	if document.Challenge != nil {
		err = document.Challenge.Prove(challengeSolution)
		if err != nil {
			return "", err
		}
	}

	return document.Token, nil
}
